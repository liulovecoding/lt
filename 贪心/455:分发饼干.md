**思路(也是贪心策略)**：给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干

**具体实现**：因为我们需要获得大小关系，所以对孩子和饼干分别排序(从小到大)

**代码：**
```
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(),g.end());
    sort(s.begin(),s.end());
    int i=0,j=0;
    while(i<g.size()&&j<s.size()){
        if(g[i]<=s[j])
        i++;
        j++;//无论是否能喂饱都需要加一
    }
    return i;
 }    
    
};
```

![QQ截图20210929223004](https://user-images.githubusercontent.com/90401274/135289490-d04fdf12-8093-421d-a156-f499d516d062.png)

**复杂度分析**

1. 时间复杂度：O(mlog m + nlog n)O(mlogm+nlogn)，其中 mm 和 nn 分别是数组 g 和 s 的长度。对两个数组排序的时间复杂度是 O(mlog m + nlog n)O(mlogm+nlogn)，遍历数组的时间复杂度是 O(m+n)O(m+n)，因此总时间复杂度是 O(mlog m + nlog n)O(mlogm+nlogn)。

2. 空间复杂度：O(log m + log n)O(logm+logn)，其中 mm 和 nn 分别是数组 g 和 s 的长度。空间复杂度主要是排序的额外空间开销。
